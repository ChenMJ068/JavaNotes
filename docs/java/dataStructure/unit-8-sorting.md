# 排序
目录：
<!-- TOC -->
- [栈](#栈) 
- [1.排序的基本概念](#排序的基本概念)
- [2.插入排序](#插入排序)
    - [2.1 直接插入排序](#直接插入排序)
    - [2.2 折半插入排序](#折半插入排序)
    - [2.3 希尔排序](#希尔排序)
- [3.交换排序](#交换排序)
    - [3.1 冒泡排序](#冒泡排序)
    - [3.2 快速排序](#快速排序)
- [4.选择排序](#选择排序)
    - [4.1 直接选择排序](#直接选择排序)
    - [4.2 堆排序](#堆排序)
- [5.归并排序](#归并排序)
- [6.单链表的排序算法](#单链表的排序算法)
    - [6.1 单链表的直接插入排序](#单链表的直接插入排序)
    - [6.2 单链表的直接选择排序](#单链表的直接选择排序)
    - [6.3 单链表的归并算法](#单链表的归并算法)
<!-- /MarkdownTOC -->
## 1.排序的基本概念
1.排序的数据序列与关键字  
数据序列是指待排序的数据元素集合，排序是以关键字为标准进行的。比如数据库中按照创建时间进行倒序。  
2.排序算法的性能评价  
衡量排序算法性能的标准是排序算法的时间复杂度和空间复杂度。  
3.排序算法的稳定性  
排序算法的稳定性是指关键字重复情况下的排序性能。假设有两列关键字相等的数据a和b。a在b之前，排序后a仍在b之前，这样的算法是稳定的，否则是不稳定的  
4.内排序和外排序  
排序的内、外是相对于内存而言。内排序是指待排序的数据元素全部存储在内存；外排序是指待排序的数据元素非常多，不能全部存储在内存中，需要将存储在外部存储介质
上的数据分批导入内存，分批排序。

## 2.插入排序
每次将一个元素，按其关键字大小插入到它前面已排序的子列中，被插入的子序列仍是排序的，依次重复，直到全部元素插入完毕。
### 2.1.直接插入排序
数据序列长度为n，直接插入排序需要n-1次，每次将一个元素插入到它前面的子序列中。  
对数组{67,45,12,98,64,33,54,77,11,48}进行排序
代码实现：
```java
public class ArraySort {
    public static void insertSort(int[] array){
           //n-1次扫描，从数组的第二个元素开始
           for (int i = 1; i < array.length; i++) {
               //每次将array[i]插入到前面已排序的数组中
               int temp = array[i],j;
               //将前面较大的元素向后移动
               for (j = i-1;j>=0 && temp < array[j]; j--) {
                   array[j+1] = array[j];
               }
               //temp值插入目标位置
               array[j+1] = temp;
               System.out.println("第"+i+"次:"+ Arrays.toString(array));
           }
     }
}
```
代码执行结果：
```
第1次:[45, 67, 12, 98, 64, 33, 54, 77, 11, 48]
第2次:[12, 45, 67, 98, 64, 33, 54, 77, 11, 48]
第3次:[12, 45, 67, 98, 64, 33, 54, 77, 11, 48]
第4次:[12, 45, 64, 67, 98, 33, 54, 77, 11, 48]
第5次:[12, 33, 45, 64, 67, 98, 54, 77, 11, 48]
第6次:[12, 33, 45, 54, 64, 67, 98, 77, 11, 48]
第7次:[12, 33, 45, 54, 64, 67, 77, 98, 11, 48]
第8次:[11, 12, 33, 45, 54, 64, 67, 77, 98, 48]
第9次:[11, 12, 33, 45, 48, 54, 64, 67, 77, 98]
```

**直接插入排序算法分析**  
数组的长度为n，直接插入排序算法需要执行n-1次，每次的比较次数和移动次数与数据长度的初始排列有关，最理想的情况下为待排序的数组
已经是排好序的，此时的时间复杂度为$O(n)$;最糟糕的情况下为待排序的数组是反序数组，此时的时间复杂度为$O(n^2)$。  
总之，数组的初始排列越接近有序，直接插入排序的时间效率越高，效率在$O(n)$与$O(n^2)$之间。直接插入排序的空间复杂度为$O(1)$，
所以直接插入排序算法是稳定的。
### 2.2.折半插入排序
直接插入排序的每一趟，将待排序元素a插入到它前面的一个已排序的子序列中，其中采用顺序查找算法寻找a的插入位置。此时，子序列是已排序
的且顺序存储，这两条正好符合折半查找的要求，因此用折半查找代替直接插入排序中顺序查找，则构成折半插入排序。
代码入下：
```java
public class ArraySort {
     public static void binaryInsertSort(int[] array){
            for(int i = 1; i < array.length; i++){
                int temp = array[i],low = 0,high = i - 1;
                //折半查找应该插入的位置
                while(low <= high){
                    int mid = (low + high) / 2;
                    if(temp < array[mid]){
                        high = mid - 1;
                    }else{
                        low = mid + 1;
                    }
                }
                //统一移动元素，然后将这个元素插入到正确的位置
                for(int j = i; j >= low + 1; j--){
                    array[j] = array[j - 1];
                }
                array[low] = temp;
                System.out.println("第"+i+"次:"+ Arrays.toString(array));
            }
        }
}
```
代码执行结果：
```
第1次:[45, 67, 12, 98, 64, 33, 54, 77, 11, 48]
第2次:[12, 45, 67, 98, 64, 33, 54, 77, 11, 48]
第3次:[12, 45, 67, 98, 64, 33, 54, 77, 11, 48]
第4次:[12, 45, 64, 67, 98, 33, 54, 77, 11, 48]
第5次:[12, 33, 45, 64, 67, 98, 54, 77, 11, 48]
第6次:[12, 33, 45, 54, 64, 67, 98, 77, 11, 48]
第7次:[12, 33, 45, 54, 64, 67, 77, 98, 11, 48]
第8次:[11, 12, 33, 45, 54, 64, 67, 77, 98, 48]
第9次:[11, 12, 33, 45, 48, 54, 64, 67, 77, 98]
```
### 2.3.希尔排序
希尔排序又称为缩小增量排序，简单点理解为分组执行直接插入排序。  
希尔算法描述入下：
1.将一个数组分成若干组，每组由若干相隔一段距离的元素组成，这段距离称为增量，在一个组内采用直接插入排序算法进行排序。  
2.增量的初始值通常为数据序列长度的一半，以后每一次增量逐渐缩小，最后值为1.随着增量逐渐减小，组数也减少，组内元素个数增加，整个序列则接近有序。

代码入下：
```java
public class ArraySort {
     public static void shellSort(int[] array){
            //若干趟扫描，控制增量，增量减半
            for (int i = array.length/2;i>0;i/=2){
                //一趟分若干组，每组进行直接插入排序
                for (int j = i; j < array.length; j++) {
                    //temp是当前待排序插入的元素
                    int temp = array[j],m;
                    //每组元素相距距离为i，寻找插入位置
                    for (m = j-i; m >= 0 && temp < array[m]; m-=i) {
                        //插入元素
                        array[m+i] = array[m];
                    }
                    array[m+i] = temp;
                }
                System.out.println("第"+i+"次:"+ Arrays.toString(array));
            }
     }
}
```
代码执行结果：
```
第5次:[33, 45, 12, 11, 48, 67, 54, 77, 98, 64]
第2次:[12, 11, 33, 45, 48, 64, 54, 67, 98, 77]
第1次:[11, 12, 33, 45, 48, 54, 64, 67, 77, 98]
```
## 3.交换排序
### 3.1.冒泡排序
冒泡排序：比较相邻的两个数据元素，如果反序就交换。若按升序排列，
每一次就将被扫描的数据序列中最大数据元素交换到最后位置，就想气泡水里冒出一样。

代码入下：
```java
public class ArraySort {
    public static void bubbleSort(int[] array){
            for (int i = 1; i < array.length; i++) {
                for (int j = 0; j < array.length-1; j++) {
                    //降序
                    if (array[j] < array[j+1]){
                        int temp = array[j+1];
                        array[j+1] = array[j];
                        array[j] = temp;
                    }
                    //升序
                   /* if (array[j] > array[j+1]){
                        int temp = array[j];
                        array[j] = array[j+1];
                        array[j+1] = temp;
                    }*/
                }
                System.out.println("第"+i+"次:"+ Arrays.toString(array));
            }
        }
}
```
代码执行结果：
```
第1次:[67, 45, 98, 64, 33, 54, 77, 12, 48, 11]
第2次:[67, 98, 64, 45, 54, 77, 33, 48, 12, 11]
第3次:[98, 67, 64, 54, 77, 45, 48, 33, 12, 11]
第4次:[98, 67, 64, 77, 54, 48, 45, 33, 12, 11]
第5次:[98, 67, 77, 64, 54, 48, 45, 33, 12, 11]
第6次:[98, 77, 67, 64, 54, 48, 45, 33, 12, 11]
第7次:[98, 77, 67, 64, 54, 48, 45, 33, 12, 11]
第8次:[98, 77, 67, 64, 54, 48, 45, 33, 12, 11]
第9次:[98, 77, 67, 64, 54, 48, 45, 33, 12, 11]
```
**冒泡排序算法分析**  
冒泡排序最好情况下是数据初始序列已排序，只需要一次扫描，比较次数为n。没有数据移动，时间复杂度为$O(n)$,
最坏情况下是数据元素反序排列，需要n-1次扫描，比较次数和移动次数都是$O(n^2)$。所以，数据序列的初始排列越接近有序，冒泡排序的效率就越高，
效率在$O(n)$与$O(n^2)$之间。冒泡排序是稳定的算法。
### 3.2.快速排序
jdk API中默认使用的是快速排序，为Arrays.class中的sort方法。其中描述是这样的排序算法是由Vladimir Yaroslavskiy，
Jon Bentley和Joshua Bloch提供的双轴快速排序。 该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，
并且通常比传统（单轴）Quicksort实现更快，具体源码实现请参考jdk中。

## 4.选择排序
### 4.1直接选择排序
直接选择排序：第一趟从n个数据元素的数据序列中选出关键字最小（或最大）的元素并放到最前（或最后）位置，下一趟再从n-1个元素中选出最小（大）
的元素并当道次前(后)位置，以此类推，经过n-1趟完成排序。

代码实现如下：
```java
public class ArraySort {
    public static void selectSort(int[] array){
            for (int i = 0; i < array.length-1; i++) {
                int min = 1;
                for (int j = i+1; j < array.length; j++) {
                    if (array[j] < array[min]){
                        min = j;
                    }
                }
                if (min != i){
                    int temp = array[i];
                    array[i] = array[min];
                    array[min] = temp;
                }
                System.out.println("第"+i+"次:"+ Arrays.toString(array));
            }
        }
}
```
执行结果：
```
第0次:[11, 45, 12, 98, 64, 33, 54, 77, 67, 48]
第1次:[11, 12, 45, 98, 64, 33, 54, 77, 67, 48]
第2次:[11, 45, 12, 98, 64, 33, 54, 77, 67, 48]
第3次:[11, 45, 12, 33, 64, 98, 54, 77, 67, 48]
第4次:[11, 64, 12, 33, 45, 98, 54, 77, 67, 48]
第5次:[11, 64, 12, 33, 45, 48, 54, 77, 67, 98]
第6次:[11, 54, 12, 33, 45, 48, 64, 77, 67, 98]
第7次:[11, 77, 12, 33, 45, 48, 64, 54, 67, 98]
第8次:[11, 67, 12, 33, 45, 48, 64, 54, 77, 98]
```
**直接选择排序算法分析：**  
直接选择排序的比较次数与数据的初始排列无关，直接选择排序总比较次数为：$n^2$/2。移动次数与数据序列的初始排列有关。当数据序列已排序时，移动次数为0，
当数据序列反序排列时，每一趟排序都需要交换，移动次数为3(n-1).因此它的时间复杂度为$O(n^2)$,空间复杂度为$O(n^2)$。直接选择排序是不稳定的。
### 4.2.堆排序
堆排序时完全二叉树的应用，是充分利用完全二叉树的特性的一种选择排序。  

## 5.归并排序

## 6.单链表的排序方法

### 6.1.单链表的直接插入排序

### 6.2.单链表的直接选择排序

### 6.3.单链表的归并算法
