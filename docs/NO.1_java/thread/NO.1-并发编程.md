# 并发编程
目录：
<!-- TOC -->
- [并发编程](#并发编程)
 - [初探并发](#初探并发)
    - [并发与并行](#并发与并行)
    - [并发编程会带来哪些问题](#并发编程会带来哪些问题)
        - [缓存导致的可见性问题](#缓存导致的可见性问题)
        - [线程切换带来的原子性问题](#线程切换带来的原子性问题)
        - [编译优化带来的有序性问题](#编译优化带来的有序性问题)
 - [线程](#线程)
    - [什么是线程和进程](#什么是线程和进程)
    - [线程的生命周期](#线程的生命周期)
    - [创建线程的方式](#创建线程的方式)
 
<!-- /MarkdownTOC -->


## 初探并发
在科技飞速发展的今天，CPU、内存、I/O设备都在快速迭代升级。硬件设备升级的同时，对软件的要求也在不断增加。
查看BOSS直聘的招聘需求可以发现，很多公司都要求待聘者具有高并发，高性能的分布式开发经验。

### 并发与并行
- **并发：** 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
- **并行：** 单位时间内，多个任务同时执行。

### 并发编程会带来哪些问题
我们知道CPU、内存、I/O设备都在快速迭代升级，但是在快速发展的过程中，有一个核心矛盾一直存在，就是这三者之间的差距。CPU、内存、
I/O设备之间的速度差异可以形象比喻为CPU天上一天、内存为地上一年，内存天上一天、I/O设备为地上十年。根据木桶理论（一只水桶能装
多少水取决于它最短的那块木板），程序整体的性能取决于最慢的操作——读写 I/O 设备，也就是说单方面提高 CPU 性能是无效的。为了平衡这
三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：
- CPU 增加了缓存，以均衡与内存的速度差异；
- 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

现在我们几乎所有的程序都默默地享受着这些成果，但是天下没有免费的午餐，并发程序很多诡异问题的根源也在这里。

#### 缓存导致的可见性问题
首先，在单核时代，所有线程都是在一个cpu上执行的，所以所有线程之间的缓存和内存数据都是可见的。
到了多核时代，每颗cpu都有自己的缓存，由于cpu都是个体，所以缓存和内存数据是不可见的。这就导致了可见性问题。这是硬件工程师给软件
工程师挖的坑

#### 线程切换带来的原子性问题
多线程在执行的时候，cpu会分布时间片，每个线程在这个时间片中执行一段时间后，会切换到下一个任务执行，等重新分配到时间片后，这个
线程会继续执行。这种方式被称为任务切换，记录任务执行位置叫做程序计数器。但是一个任务在切换时会带来原子性问题，举个例子来说：我
们对count进行加1操作，cpu至少要执行三条指令：
- 首先，把变量count从内存加载到cpu的寄存器中；
- 然后，在寄存器中执行价1操作；
- 最后，将结果写入缓存或内存中；
在做任务切换时，可以发生在任何一条cpu指令中，而不是java语句中的一条语句。所以在多线程对count加1的操作时，会破坏它的原子性。

#### 编译优化带来的有序性问题
有序性是指程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序；比如a=6，b=7，编译器优化后可能会变
成b=7，a=6。虽然语句的顺序被改变了，但是不影响结果最终结果。不过有时候编译器及解释器的优化可能会导致意想不到的bug。

## 线程
### 什么是线程和进程

### 线程的生命周期

### 创建线程的方式
