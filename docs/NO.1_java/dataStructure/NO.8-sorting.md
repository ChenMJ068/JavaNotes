# 排序
目录：
<!-- TOC -->
- [栈](#栈) 
- [1.排序的基本概念](#排序的基本概念)
- [2.插入排序](#插入排序)
    - [2.1 直接插入排序](#直接插入排序)
    - [2.2 折半插入排序](#折半插入排序)
    - [2.3 希尔排序](#希尔排序)
- [3.交换排序](#交换排序)
    - [3.1 冒泡排序](#冒泡排序)
    - [3.2 快速排序](#快速排序)
- [4.选择排序](#选择排序)
    - [4.1 直接选择排序](#直接选择排序)
    - [4.2 堆排序](#堆排序)
- [5.归并排序](#归并排序)
)
<!-- /MarkdownTOC -->
## 1.排序的基本概念
1.排序的数据序列与关键字  
数据序列是指待排序的数据元素集合，排序是以关键字为标准进行的。比如数据库中按照创建时间进行倒序。  
2.排序算法的性能评价  
衡量排序算法性能的标准是排序算法的时间复杂度和空间复杂度。  
3.排序算法的稳定性  
排序算法的稳定性是指关键字重复情况下的排序性能。假设有两列关键字相等的数据a和b。a在b之前，排序后a仍在b之前，这样的算法是稳定的，否则是不稳定的  
4.内排序和外排序  
排序的内、外是相对于内存而言。内排序是指待排序的数据元素全部存储在内存；外排序是指待排序的数据元素非常多，不能全部存储在内存中，需要将存储在外部存储介质
上的数据分批导入内存，分批排序。

## 2.插入排序
每次将一个元素，按其关键字大小插入到它前面已排序的子列中，被插入的子序列仍是排序的，依次重复，直到全部元素插入完毕。
### 2.1.直接插入排序
数据序列长度为n，直接插入排序需要n-1次，每次将一个元素插入到它前面的子序列中。  
对数组{67,45,12,98,64,33,54,77,11,48}进行排序
代码实现：
```java
public class ArraySort {
    public static void insertSort(int[] array){
           //n-1次扫描，从数组的第二个元素开始
           for (int i = 1; i < array.length; i++) {
               //每次将array[i]插入到前面已排序的数组中
               int temp = array[i],j;
               //将前面较大的元素向后移动
               for (j = i-1;j>=0 && temp < array[j]; j--) {
                   array[j+1] = array[j];
               }
               //temp值插入目标位置
               array[j+1] = temp;
               System.out.println("第"+i+"次:"+ Arrays.toString(array));
           }
     }
}
```
代码执行结果：
```
第1次:[45, 67, 12, 98, 64, 33, 54, 77, 11, 48]
第2次:[12, 45, 67, 98, 64, 33, 54, 77, 11, 48]
第3次:[12, 45, 67, 98, 64, 33, 54, 77, 11, 48]
第4次:[12, 45, 64, 67, 98, 33, 54, 77, 11, 48]
第5次:[12, 33, 45, 64, 67, 98, 54, 77, 11, 48]
第6次:[12, 33, 45, 54, 64, 67, 98, 77, 11, 48]
第7次:[12, 33, 45, 54, 64, 67, 77, 98, 11, 48]
第8次:[11, 12, 33, 45, 54, 64, 67, 77, 98, 48]
第9次:[11, 12, 33, 45, 48, 54, 64, 67, 77, 98]
```

**直接插入排序算法分析**  
数组的长度为n，直接插入排序算法需要执行n-1次，每次的比较次数和移动次数与数据长度的初始排列有关，最理想的情况下为待排序的数组
已经是排好序的，此时的时间复杂度为$O(n)$;最糟糕的情况下为待排序的数组是反序数组，此时的时间复杂度为$O(n^2)$。  
总之，数组的初始排列越接近有序，直接插入排序的时间效率越高，效率在$O(n)$与$O(n^2)$之间。直接插入排序的空间复杂度为$O(1)$，
所以直接插入排序算法是稳定的。
### 2.2.折半插入排序
直接插入排序的每一趟，将待排序元素a插入到它前面的一个已排序的子序列中，其中采用顺序查找算法寻找a的插入位置。此时，子序列是已排序
的且顺序存储，这两条正好符合折半查找的要求，因此用折半查找代替直接插入排序中顺序查找，则构成折半插入排序。
代码入下：
```java
public class ArraySort {
     public static void binaryInsertSort(int[] array){
            for(int i = 1; i < array.length; i++){
                int temp = array[i],low = 0,high = i - 1;
                //折半查找应该插入的位置
                while(low <= high){
                    int mid = (low + high) / 2;
                    if(temp < array[mid]){
                        high = mid - 1;
                    }else{
                        low = mid + 1;
                    }
                }
                //统一移动元素，然后将这个元素插入到正确的位置
                for(int j = i; j >= low + 1; j--){
                    array[j] = array[j - 1];
                }
                array[low] = temp;
                System.out.println("第"+i+"次:"+ Arrays.toString(array));
            }
        }
}
```
代码执行结果：
```
第1次:[45, 67, 12, 98, 64, 33, 54, 77, 11, 48]
第2次:[12, 45, 67, 98, 64, 33, 54, 77, 11, 48]
第3次:[12, 45, 67, 98, 64, 33, 54, 77, 11, 48]
第4次:[12, 45, 64, 67, 98, 33, 54, 77, 11, 48]
第5次:[12, 33, 45, 64, 67, 98, 54, 77, 11, 48]
第6次:[12, 33, 45, 54, 64, 67, 98, 77, 11, 48]
第7次:[12, 33, 45, 54, 64, 67, 77, 98, 11, 48]
第8次:[11, 12, 33, 45, 54, 64, 67, 77, 98, 48]
第9次:[11, 12, 33, 45, 48, 54, 64, 67, 77, 98]
```
### 2.3.希尔排序
希尔排序又称为缩小增量排序，简单点理解为分组执行直接插入排序。  
希尔算法描述入下：
1.将一个数组分成若干组，每组由若干相隔一段距离的元素组成，这段距离称为增量，在一个组内采用直接插入排序算法进行排序。  
2.增量的初始值通常为数据序列长度的一半，以后每一次增量逐渐缩小，最后值为1.随着增量逐渐减小，组数也减少，组内元素个数增加，整个序列则接近有序。

代码入下：
```java
public class ArraySort {
     public static void shellSort(int[] array){
            //若干趟扫描，控制增量，增量减半
            for (int i = array.length/2;i>0;i/=2){
                //一趟分若干组，每组进行直接插入排序
                for (int j = i; j < array.length; j++) {
                    //temp是当前待排序插入的元素
                    int temp = array[j],m;
                    //每组元素相距距离为i，寻找插入位置
                    for (m = j-i; m >= 0 && temp < array[m]; m-=i) {
                        //插入元素
                        array[m+i] = array[m];
                    }
                    array[m+i] = temp;
                }
                System.out.println("第"+i+"次:"+ Arrays.toString(array));
            }
     }
}
```
代码执行结果：
```
第5次:[33, 45, 12, 11, 48, 67, 54, 77, 98, 64]
第2次:[12, 11, 33, 45, 48, 64, 54, 67, 98, 77]
第1次:[11, 12, 33, 45, 48, 54, 64, 67, 77, 98]
```
## 3.交换排序
### 3.1.冒泡排序
冒泡排序：比较相邻的两个数据元素，如果反序就交换。若按升序排列，
每一次就将被扫描的数据序列中最大数据元素交换到最后位置，就想气泡水里冒出一样。

代码入下：
```java
public class ArraySort {
    public static void bubbleSort(int[] array){
            for (int i = 1; i < array.length; i++) {
                for (int j = 0; j < array.length-1; j++) {
                    //降序
                    if (array[j] < array[j+1]){
                        int temp = array[j+1];
                        array[j+1] = array[j];
                        array[j] = temp;
                    }
                    //升序
                   /* if (array[j] > array[j+1]){
                        int temp = array[j];
                        array[j] = array[j+1];
                        array[j+1] = temp;
                    }*/
                }
                System.out.println("第"+i+"次:"+ Arrays.toString(array));
            }
        }
}
```
代码执行结果：
```
第1次:[67, 45, 98, 64, 33, 54, 77, 12, 48, 11]
第2次:[67, 98, 64, 45, 54, 77, 33, 48, 12, 11]
第3次:[98, 67, 64, 54, 77, 45, 48, 33, 12, 11]
第4次:[98, 67, 64, 77, 54, 48, 45, 33, 12, 11]
第5次:[98, 67, 77, 64, 54, 48, 45, 33, 12, 11]
第6次:[98, 77, 67, 64, 54, 48, 45, 33, 12, 11]
第7次:[98, 77, 67, 64, 54, 48, 45, 33, 12, 11]
第8次:[98, 77, 67, 64, 54, 48, 45, 33, 12, 11]
第9次:[98, 77, 67, 64, 54, 48, 45, 33, 12, 11]
```
**冒泡排序算法分析**  
冒泡排序最好情况下是数据初始序列已排序，只需要一次扫描，比较次数为n。没有数据移动，时间复杂度为$O(n)$,
最坏情况下是数据元素反序排列，需要n-1次扫描，比较次数和移动次数都是$O(n^2)$。所以，数据序列的初始排列越接近有序，冒泡排序的效率就越高，
效率在$O(n)$与$O(n^2)$之间。冒泡排序是稳定的算法。
### 3.2.快速排序
jdk API中默认使用的是快速排序，为Arrays.class中的sort方法。其中描述是这样的排序算法是由Vladimir Yaroslavskiy，
Jon Bentley和Joshua Bloch提供的双轴快速排序。 该算法在许多数据集上提供O（n log（n））性能，导致其他快速排序降级为二次性能，
并且通常比传统（单轴）Quicksort实现更快，具体源码实现请参考jdk中。

## 4.选择排序
### 4.1直接选择排序
直接选择排序：第一趟从n个数据元素的数据序列中选出关键字最小（或最大）的元素并放到最前（或最后）位置，下一趟再从n-1个元素中选出最小（大）
的元素并当道次前(后)位置，以此类推，经过n-1趟完成排序。

代码实现如下：
```java
public class ArraySort {
    public static void selectSort(int[] array){
            for (int i = 0; i < array.length-1; i++) {
                int min = 1;
                for (int j = i+1; j < array.length; j++) {
                    if (array[j] < array[min]){
                        min = j;
                    }
                }
                if (min != i){
                    int temp = array[i];
                    array[i] = array[min];
                    array[min] = temp;
                }
                System.out.println("第"+i+"次:"+ Arrays.toString(array));
            }
        }
}
```
执行结果：
```
第0次:[11, 45, 12, 98, 64, 33, 54, 77, 67, 48]
第1次:[11, 12, 45, 98, 64, 33, 54, 77, 67, 48]
第2次:[11, 45, 12, 98, 64, 33, 54, 77, 67, 48]
第3次:[11, 45, 12, 33, 64, 98, 54, 77, 67, 48]
第4次:[11, 64, 12, 33, 45, 98, 54, 77, 67, 48]
第5次:[11, 64, 12, 33, 45, 48, 54, 77, 67, 98]
第6次:[11, 54, 12, 33, 45, 48, 64, 77, 67, 98]
第7次:[11, 77, 12, 33, 45, 48, 64, 54, 67, 98]
第8次:[11, 67, 12, 33, 45, 48, 64, 54, 77, 98]
```
**直接选择排序算法分析：**  
直接选择排序的比较次数与数据的初始排列无关，直接选择排序总比较次数为：$n^2$/2。移动次数与数据序列的初始排列有关。当数据序列已排序时，移动次数为0，
当数据序列反序排列时，每一趟排序都需要交换，移动次数为3(n-1).因此它的时间复杂度为$O(n^2)$,空间复杂度为$O(n^2)$。直接选择排序是不稳定的。
### 4.2.堆排序
堆排序时完全二叉树的应用，是充分利用完全二叉树的特性的一种选择排序。  

堆是具有以下性质的完全二叉树：
- 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]；
- 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆，arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]。

堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为
最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

堆排序的基本思路：
- a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
- b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
- c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

代码实现：
```java
public class ArraySort {
     public static void headSort(int[] array){
            int n = array.length;
            for (int j= array.length/2-1;j>=0;j--){
                sift(array,j,n-1);
            }
            for (int j = n-1;j>0;j--){
                int temp = array[0];
                array[0] = array[j];
                array[j] = temp;
                sift(array,0,j-1);
            }
        }
        private static void sift(int[] array,int begin,int end){
            int i = begin,j=2*i+1;
            int temp = array[i];
            while(j<=end){
                if (j<end && array[j]>array[j+1]){
                    j++;
                }
                if (temp > array[j]){
                    array[i] = array[j];
                    i = j;
                    j = 2*i+1;
                }else{
                    break;
                }
            }
            array[i] = temp;
        }
}
```
代码执行结果：
```
堆排序当前变更结果:[12, 45, 33, 67, 48, 64, 54, 77, 98, 11]
堆排序当前变更结果:[33, 45, 54, 67, 48, 64, 98, 77, 12, 11]
堆排序当前变更结果:[45, 48, 54, 67, 77, 64, 98, 33, 12, 11]
堆排序当前变更结果:[48, 67, 54, 98, 77, 64, 45, 33, 12, 11]
堆排序当前变更结果:[54, 67, 64, 98, 77, 48, 45, 33, 12, 11]
堆排序当前变更结果:[64, 67, 77, 98, 54, 48, 45, 33, 12, 11]
堆排序当前变更结果:[67, 98, 77, 64, 54, 48, 45, 33, 12, 11]
堆排序当前变更结果:[77, 98, 67, 64, 54, 48, 45, 33, 12, 11]
堆排序当前变更结果:[98, 77, 67, 64, 54, 48, 45, 33, 12, 11]
```
**堆排序算法分析**
堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为$O(n)$，
在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，$[log_2 (n-1),log_2 (n-2)...1]$逐步递减，
近似为&nlogn$。所以堆排序时间复杂度一般认为就是$O(nlogn)$级
## 5.归并排序
归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
它是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序
子序列合并为整体有序序列。归并排序又称为两路归并排序

归并排序由于使用了分治法，所以包括三个步骤：分解、解决、合并。核心操作就是一次合并过程。

代码实现如下：
```java
public class ArraySort {
    //将x中两个相邻子序列归并Y中
     private static void merge(int[] X,int[] Y,int m,int r,int n){
            int i=m,j=r,k=m;
            while (i<r && j<r+n && j<X.length){
                if (X[i] < X[j]){
                    Y[k++] = X[i++];
                }else{
                    Y[k++] = X[j++];
                }
            }
            while (i<r){
                Y[k++] = X[i++];
            }
            while (j<r+n && j<X.length){
                Y[k++] = X[j++];
            }
        }
}
```
一趟排序：
```java
public class ArraySort {
    private static void mergePass(int[] X,int[] Y,int n){
            int i = 0;
            while (i<X.length-2*n+1){
                merge(X,Y,i,i+n,n);
                i += 2*n;
            }
            if (i+n<X.length){
                merge(X,Y,i,i+n,n);
            }else{
                if (X.length - i >= 0){
                    System.arraycopy(X, i, Y, i, X.length - i);
                }
            }
        }
}
```
最终合并：
```java
public class ArraySort {
     public static void mergeSort(int[] array){
            int[] y = new int[array.length];
            int n = 1;
            while (n<array.length){
                mergePass(array,y,n);
                n *= 2;
                if (n < array.length){
                    mergePass(y,array,n);
                    n *= 2;
                }
            }
            System.out.println("归并排序:"+Arrays.toString(array));
        }
}
```

代码执行结果：
```
归并排序:[11, 12, 33, 45, 48, 54, 64, 67, 77, 98]
```
**归并算法分析**
时间复杂度为O(nlogn),空间复杂度为O(n+logn)，由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归
时深度为log2n的栈空间。

归并排序是一种比较占用内存，但却效率高且稳定的算法。

非递归的迭代方法，避免了递归时深度为log2n的栈空间，因此空间复杂度为O(n).并且避免递归在时间性能上有一定的提升
（函数调用的开销）。所以，使用归并排序时，尽量考虑使用非递归方法。

链接：[文档地址](https://github.com/Chenide/JavaNotes) [源码地址](https://github.com/Chenide/core-structure-aglo)